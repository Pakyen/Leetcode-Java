# 7. 不同的二叉搜索树

## 题目来源
[Leetcode96 - 不同的二叉搜索树](https://leetcode-cn.com/problems/unique-binary-search-trees/)

## 题目描述
给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？
![](7.%20%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/%E6%88%AA%E5%B1%8F2021-07-11%2016.40.26.png)
![](7.%20%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/%E6%88%AA%E5%B1%8F2021-07-11%2016.40.37.png)

> BST：右子节点比父节点大，父节点比左子节点大  

## 解题思路
先画画图，找规律
![](7.%20%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/95419664-2A14-4E03-9198-F42297B304F4.png)
![](7.%20%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/04260DE3-FC92-4954-8C3E-F98FC94092FA.png)

> 来看看n为3的时候，有哪几种情况。  
> 当1为头结点的时候，其右子树有两个节点，看这两个节点的布局，是不是和 n 为2的时候两棵树的布局是一样的啊！  
> （可能有同学问了，这布局不一样啊，节点数值都不一样。别忘了我们就是求不同树的数量，并不用把搜索树都列出来，所以不用关心其具体数值的差异）  
> 当3为头结点的时候，其左子树有两个节点，看这两个节点的布局，是不是和n为2的时候两棵树的布局也是一样的啊！  
> 当2位头结点的时候，其左右子树都只有一个节点，布局是不是和n为1的时候只有一棵树的布局也是一样的啊！  
> 发现到这里，其实我们就找到的重叠子问题了，其实也就是发现可以通过dp[1] 和 dp[2] 来推导出来dp[3]的某种方式。  
> 思考到这里，这道题目就有眉目了。  

dp[3]，就是 元素1为头结点搜索树的数量 + 元素2为头结点搜索树的数量 + 元素3为头结点搜索树的数量
元素1为头结点搜索树的数量 = 右子树有2个元素的搜索树数量 * 左子树有0个元素的搜索树数量
元素2为头结点搜索树的数量 = 右子树有1个元素的搜索树数量 * 左子树有1个元素的搜索树数量
元素3为头结点搜索树的数量 = 右子树有0个元素的搜索树数量 * 左子树有2个元素的搜索树数量
有2个元素的搜索树数量就是dp[2]。
有1个元素的搜索树数量就是dp[1]。
有0个元素的搜索树数量就是dp[0]。
所以dp[3] = dp[2] * dp[0] + dp[1] * dp[1] + dp[0] * dp[2]


动态规划解题步骤：
	1. 确定dp数组（dp table）以及下标的含义
	**dp[i] ：1到i为节点组成的二叉搜索树的个数为dp[i]**

	2. 确定递推公式
	在上面的分析中，其实已经看出其递推关系， dp[i] += dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量]
j相当于是头结点的元素，从1遍历到i为止。
所以递推公式：dp[i] += dp[j - 1] * dp[i - j]; ，j-1 为j为头结点左子树节点数量，i-j 为以j为头结点右子树节点数量
	
	3. dp数组如何初始化
	dp[0]=1
	
	4. 确定遍历顺序
```
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= i; j++) {
        dp[i] += dp[j - 1] * dp[i - j];
    }
}
```
	5. 举例推导dp数组


## 代码
```
class Solution {
    public int numTrees(int n) {
        int[] dp = new int[n+1];
        dp[0]=1;
        for(int i=1; i<=n; i++){
            for(int j=1;j<=i;j++){
                dp[i] += dp[j-1]*dp[i-j];
            }
        }
        return dp[n];
    }
}
```


## 复杂度分析
	* 	时间复杂度O(n^2)
	* 	空间复杂度O(n)