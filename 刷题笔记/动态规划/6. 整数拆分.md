# 6. 整数拆分

## 题目来源
[Leetcode343 - 整数拆分](https://leetcode-cn.com/problems/integer-break/)

## 题目描述
给定一个正整数`n`，将其拆分为**至少**两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。
![](6.%20%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86/%E6%88%AA%E5%B1%8F2021-07-11%2016.14.54.png)

**说明:**你可以假设 *n*不小于 2 且不大于 58。

## 解题思路
看到这道题目，都会想拆成两个呢，还是三个呢，还是四个….

	1. 确定dp数组（dp table）以及下标的含义
	`dp[i]`：表示拆分数字`i`可以得到的最大乘积为dp[i]

	2. 确定递推公式
	对于一个dp[i]来说，我们可以有两种方式得到它
	首先从1开始遍历j
		* `dp[i] = j * ( i - j)` 拆分成两个
		* `dp[i] = j * dp[i-j] `，相当于拆分(i-j)，而(i-j)拆分的最大值已经在dp[i-j]中得到了
	然后比较这两项还有dp[i]本身的大小，取三项中较大的一项就是dp[i]
	`dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));`
	3. dp数组如何初始化
	有的题解里会给出dp[0] = 1，dp[1] = 1的初始化，但其实拆分0和拆分1是无解，没意义的。所以可以直接初始化dp[2] = 1.	

	4. 确定遍历顺序
	**正序遍历**。
	先来看看递归公式：dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));
	dp[i] 是依靠 dp[i - j]的状态，所以遍历i一定是从前向后遍历，先有dp[i - j]再有dp[i]

> 枚举j的时候，是从1开始的。i是从3开始，这样dp[i - j]就是dp[2]正好可以通过我们初始化的数值求出来  

	5. 举例推导dp数组

## 注意事项
	* `i`从3开始遍历
	* `j`从1开始遍历，而不是0，且j<i-1
## 代码
```
public int integerBreak(int n){
    int[] dp = new int[n+1];
    dp[2] = 1;
    for (int i = 3; i < n+1; i++) {
        for (int j = 1; j < i-1; j++) {
            dp[i] = Math.max(dp[i],Math.max( j*(i-j), j*dp[i-j] ));
        }
    }
    return dp[n];
}
```

## 复杂度分析
	* 时间复杂度：O(n^2)
	* 空间复杂度：O(n)

