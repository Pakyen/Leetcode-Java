# offer41 数据流中的中位数
题目：[力扣](https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/)
参考：[力扣](https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/solution/mian-shi-ti-41-shu-ju-liu-zhong-de-zhong-wei-shu-y/)
![](offer41%20%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/%E6%88%AA%E5%B1%8F2021-02-24%2014.46.14.png)
### 解题思路
> 给定一长度为 N 的无序数组，其中位数的计算方法：首先对数组执行排序（使用O(NlogN) 时间），然后返回中间元素即可（使用O(1) 时间)  

根据题目要求，将数据流保存在一个列表中，数据结构应该要保证在添加元素时，保持数组有序。
此方法的时间复杂度为O(N)，其中包括：
	* 查找元素插入位置O(logN)（二分查找）
	* 向数组某位置插入元素O(N)（插入位置之后的恶元素都需要向后移动一位）

> 借助堆可以进一步优化时间复杂度  

建立一个小顶堆A和大顶堆B,各保存列表的一半元素，且规定：
	* A保存较大的一半，长度为N/2，或者当N为奇数时保存(N+1)/2
	* B保存较小的一半，长度为N/2或者(N-1)/2
随后，中位数就可以仅仅根据A，B的堆顶元素计算得到

### 算法流程
![](offer41%20%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/A33EB150-790A-470C-AB70-9D3FEC82210B.png)
设元素总数为N=m+n，其中m和n分别为A和B中的元素个数
* addNum(num)函数：
	1. 当N为偶数时，m=n：添加元素会导致N从偶数变为奇数，所以需要向A中添加一个元素。实现方法：将新元素num插入B中，再将B的堆顶元素插入A中
	2. 当m!=n时，也就是N为奇数：需向B中添加一个元素。实现方法：将新元素插入A，再将A的堆顶元素插入到B中。
![](offer41%20%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/%E6%88%AA%E5%B1%8F2021-02-24%2015.03.03.png)

* findMedian()函数：
	1. 当m=n（N为偶数）：则中位数为(A顶+B顶)/2
	2. 当m!=n(N为奇数）：则中位数为A的堆顶元素

### 复杂度分析：
	* 时间复杂度：
		* 查找中位数：O(1)，获取堆顶元素使用O(1)时间
		* 添加数字：O(logN)，堆的插入和弹出操作使用O(logN)时间
	* 空间复杂度：
	O(N)，A和B最多同时保存N个元素

### 代码：





